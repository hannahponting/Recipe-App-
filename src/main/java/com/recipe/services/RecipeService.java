package com.recipe.services;

import com.recipe.dataaccess.RecipeRepository;
import com.recipe.entities.Recipe;
import com.recipe.utilities.*;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Service;
import org.springframework.web.server.ResponseStatusException;

import java.util.Objects;
import java.util.Optional;
import java.util.stream.Stream;


@Service
public class RecipeService {

    RecipeRepository recipeRepository;
      
    @Autowired
    public RecipeService(RecipeRepository recipeRepository){
        this.recipeRepository = recipeRepository;
    }

    public Recipe addRecipe(Recipe recipe) {
        if (Stream.of(recipe.getName(),recipe.getIngredientsList(),recipe.getInstructions(),recipe.getCuisineType(),recipe.getCostType(),recipe.getServingNo(),recipe.getTimeToCook(),recipe.getDifficultyLevel(),recipe.getMealType(),recipe.getSpiceType()).anyMatch(Objects::isNull)) {
            throw new IllegalArgumentException("All fields are mandatory other than ID which is generated by the service.");
        }
        if (recipe.getId() != null) {
            throw new IllegalArgumentException("The unique ID is generated by the service and does not need to be provided.");
        }
        if (recipe.getName() == null){
            throw new IllegalArgumentException("The recipe must have a name");
        }
        if (recipe.getInstructions() == null){
            throw new IllegalArgumentException("The recipe must have instructions");
        }
        if (recipe.getIngredientsList() == null){
            throw new IllegalArgumentException("The recipe must have instructions");
        }
        recipeRepository.save(recipe);
        return recipe;
    }

  
    public String deleteById(long id){
        Recipe proposedDeletion = recipeRepository.findRecipeById(id);
        if (proposedDeletion == null){
            throw new IllegalArgumentException("The specified recipe ID does not exist");
        }
        String name = proposedDeletion.getName();
        recipeRepository.deleteById(id);
        return "The recipe with ID " + id + " and title " + name + " has now been deleted.";
    }



    public Iterable<Recipe> findAll(){
        return this.recipeRepository.findAll();
    }

    public Recipe getRecipeById(long recipeId) {
        Optional<Recipe> recipe = this.recipeRepository.findById(recipeId);
        return recipe.orElse(null);


    }

    public Iterable<Recipe> findByNameContains(String keyword) {
        return recipeRepository.findAllByNameContainingIgnoreCase(keyword);
    }

    public Recipe updateRecipe(Recipe changesToRecipe){
        if(changesToRecipe ==null) throw new NullPointerException("No recipe entered");
        if(changesToRecipe.getId()==null) throw new IllegalArgumentException("You must specify a recipe ID to edit");
        Recipe oldRecipe= getRecipeById(changesToRecipe.getId());
        Recipe finalRecipe;
        if (oldRecipe == null) throw new ResponseStatusException(HttpStatus.NOT_FOUND, "Recipe not found");
        finalRecipe = makeChangesToRecipe(changesToRecipe, oldRecipe);
        return recipeRepository.save(finalRecipe);}


    private Recipe makeChangesToRecipe(Recipe changesToRecipe, Recipe oldRecipe) {
        if (changesToRecipe.getName() != null) oldRecipe.setName(changesToRecipe.getName());
        if (changesToRecipe.getIngredientsList() != null) oldRecipe.setIngredientsList(changesToRecipe.getIngredientsList());
        if (changesToRecipe.getInstructions() != null) oldRecipe.setInstructions(changesToRecipe.getInstructions());
        if (changesToRecipe.getServingNo() !=0) oldRecipe.setServingNo(changesToRecipe.getServingNo());
        if (changesToRecipe.getCuisineType() != null) oldRecipe.setCuisineType(changesToRecipe.getCuisineType());
        if (changesToRecipe.getTimeToCook() != null) oldRecipe.setTimeToCook(changesToRecipe.getTimeToCook());
        if (changesToRecipe.getCostType() != null) oldRecipe.setCostType(changesToRecipe.getCostType());
        if (changesToRecipe.getDifficultyLevel() != null) oldRecipe.setDifficultyLevel(changesToRecipe.getDifficultyLevel());
        if (changesToRecipe.getMealType() != null)oldRecipe.setMealType(changesToRecipe.getMealType());
        if (changesToRecipe.getSpiceType() != null) oldRecipe.setSpiceType(changesToRecipe.getSpiceType());
        return oldRecipe;
    }

    public Iterable<Recipe> findByIngredientsContain(String ingredient) {
        return recipeRepository.findAllByIngredientSearch(ingredient);
    }


    public Iterable<Recipe> getRecipeByServingNumber(int servingNo) {
        return recipeRepository.findAllByServingNo(servingNo);

    }

    public Iterable<Recipe> getRecipeByCookingTime(String timeToCook) {
        return recipeRepository.findAllByTimeToCook(timeToCook);
    }
//    public Iterable<Recipe> getRecipeByCookingTimeInMinutes(int timeToCook) {
//        return recipeRepository.findAllByTimeToCook(timeToCook);
//    }

    public Iterable<Recipe> getRecipeByCuisineType(Cuisine cuisineType) {
        return recipeRepository.findAllByCuisineType(cuisineType);
    }

    public Iterable<Recipe> getRecipeByDifficultyLevel(Difficulty difficultyLevel) {
        return recipeRepository.findAllByDifficultyLevel(difficultyLevel);

    }

    public Iterable<Recipe> getRecipeByMealType(MealTime mealType) {
        return recipeRepository.findAllByMealType(mealType);
    }

    public Iterable<Recipe> getRecipeByCostType(Cost costType) {
        return recipeRepository.findAllByCostType(costType);
    }

    public Iterable<Recipe> getRecipeBySpiceType(SpiceLevel spiceType) {
        return recipeRepository.findAllBySpiceType(spiceType);

    }

    public Iterable<Recipe> getRecipeByCookingTimeLessThanOrEqual(Double minutes) {
        return recipeRepository.findRecipeByCookingTimeLessThanOrEqualTo(minutes);
    }
}
