package com.recipe.services;

import com.recipe.dataaccess.PersonRepository;
import com.recipe.dataaccess.RatingRepository;
import com.recipe.dataaccess.RecipeRepository;
import com.recipe.entities.Rating;
import com.recipe.entities.Recipe;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.Pageable;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.stream.Stream;

@Service
public class RatingService {
    RatingRepository ratingRepository;
    PersonRepository personRepository;
    RecipeRepository recipeRepository;
    @Autowired
    public RatingService(RatingRepository ratingRepository, PersonRepository personRepository, RecipeRepository recipeRepository){
        this.ratingRepository = ratingRepository;
        this.personRepository = personRepository;
        this.recipeRepository = recipeRepository;
    }
    public Rating addRating(Rating rating) {
        if (Stream.of(rating.getRecipeId(),rating.getPersonId()).anyMatch(Objects::isNull)) {
            throw new IllegalArgumentException("A rating must include a Recipe and a User.");
        }
        if (rating.getId() != null) {
            throw new IllegalArgumentException("The unique ID is generated by the service and does not need to be provided.");
        }
        if (rating.getMyRating() != null && (rating.getMyRating() < 1 || rating.getMyRating() > 5)){
            throw new IllegalArgumentException("If a rating is provided it must be between 1 and 5.");
        }
        Optional<Rating> existingRating = ratingRepository.findByRecipeIdAndPersonId(rating.getRecipeId(), rating.getPersonId());

        if (existingRating.isPresent()) {
            Rating updatedRating = existingRating.get();
            if(rating.getMyRating() != null && rating.getMyRating() > 0 && rating.getMyRating() <= 5)updatedRating.setMyRating(rating.getMyRating());
            if(rating.isFavourite() != null)updatedRating.setFavourite(rating.isFavourite());
            return ratingRepository.save(updatedRating);
        } else {
            return ratingRepository.save(rating);
        }}

    public Double getRecipeRating(Long recipeId) {
        return ratingRepository.findAverageMyRatingByRecipeId(recipeId);
    }

    public Iterable<Recipe> getTopRecipes(int sizeOfList){
        ArrayList<Long> topRecipeIds = ratingRepository.findTopRatedRecipes(sizeOfList);
        List<Recipe> topRecipes = recipeRepository.findAllByIdIn(topRecipeIds);
        topRecipes.sort(Comparator.comparingLong(recipe -> topRecipeIds.indexOf(recipe.getId())));
        return topRecipes;
    }

    public ArrayList<Long> getRecipesRatedAtLeast(Double rating){return ratingRepository.findRecipesRatedAtLeast(rating);}

    public Iterable<Recipe> getRecipeByRatingGreaterThanOrEqual(Double rating) {
        if(rating > 5){throw new IllegalArgumentException("The highest possible rating is 5");}
        if(rating < 1){throw new IllegalArgumentException("The lowest possible rating is 1");}
        ArrayList<Long> matchingRecipes = getRecipesRatedAtLeast(rating);
        return recipeRepository.findAllByIdIn(matchingRecipes);
    }

    public Page<Recipe> getFavouriteRecipesByUser(Long person, Pageable pageable){
        ArrayList<Long> matchingRecipes = ratingRepository.findFavouriteRecipesByUser(person);
        return recipeRepository.findAllByIdIn(matchingRecipes, pageable);
    }


}
